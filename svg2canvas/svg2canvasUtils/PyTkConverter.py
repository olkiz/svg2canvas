from svgelements import *
from .ConverterABC import ConverterABC

class PyTkConverter(ConverterABC):
    def convert(self, file) -> str:
        svg = SVG.parse(file)
        shouldAddBezierFunction = False
        data = ""
        i = 0
        for element in list(svg.elements()):
            if type(element) is Rect:
                fill = element.fill if element.fill != None else ""
                stroke = element.stroke if element.stroke != None else ""
                x1 = element.x + element.width
                y1 = element.y + element.height
                data += f"canvas.create_rectangle({element.x}, {element.y}, {x1}, {y1}, width={element.stroke_width}, fill=\"{fill}\", outline=\"{stroke}\")\n"
            elif type(element) is Ellipse:
                fill = element.fill if element.fill != None else ""
                stroke = element.stroke if element.stroke != None else ""
                x0 = element.cx - element.rx
                y0 = element.cy - element.ry
                x1 = element.cx + element.rx
                y1 = element.cy + element.ry
                data += f"canvas.create_oval({x0}, {y0}, {x1}, {y1}, width={element.stroke_width}, fill=\"{fill}\", outline=\"{stroke}\")\n"
            elif type(element) is Path:
                fill = element.fill if element.fill != None else ""
                stroke = element.stroke if element.stroke != None else ""
                bezierSegmentNumber = 0
                for segment in element.segments():
                    if type(segment) is Line:
                        data += f"canvas.create_line({segment.start.x}, {segment.start.y}, {segment.end.x}, {segment.end.y}, width={element.stroke_width}, fill=\"{stroke}\")\n"
                    elif type(segment) is Close:
                        data += f"canvas.create_line({segment.start.x}, {segment.start.y}, {segment.end.x}, {segment.end.y}, width={element.stroke_width}, fill=\"{stroke}\")\n"
                    elif type(segment) is CubicBezier:
                        shouldAddBezierFunction = True
                        if bezierSegmentNumber == 0:
                            data += f"points{i} = []\n"
                        data += f"points{i} += draw_cubic_bezier(canvas, ({segment.start}), ({segment.end}), ({segment.control1}), ({segment.control2}))\n"
                        bezierSegmentNumber += 1
                if bezierSegmentNumber != 0:
                    data += f"canvas.create_polygon(points{i}, width={element.stroke_width}, fill=\"{fill}\", outline=\"{stroke}\")\n"
            i += 1
        data += self.__prepareEndString()
        if shouldAddBezierFunction:
            data = self.__prepareImportString() + self.__addBezierFunction() + self.__prepareStartString(svg.width, svg.height) + data
        else:
            data = self.__prepareImportString() + self.__prepareStartString(svg.width, svg.height) + data
        return data

    def __prepareImportString(self) -> str:
        return "import tkinter\n"

    def __prepareStartString(self, width, height) -> str:
        return f"""top = tkinter.Tk()
canvas = tkinter.Canvas(top, bg="white", height={height}, width={width})
"""

    def __prepareEndString(self) -> str:
        return f"""canvas.pack()
top.mainloop()
"""
    def __addBezierFunction(self) -> str:
        return """
# Cubic BÃ©zier function implementation
# This function was generated by OpenAI's ChatGPT model
def draw_cubic_bezier(canvas, start, end, control1, control2):
    points = []
    for t in range(0, 101):
        t = t / 100.0
        x = (1 - t) ** 3 * start[0] + 3 * (1 - t) ** 2 * t * control1[0] + 3 * (1 - t) * t ** 2 * control2[0] + t ** 3 * end[0]
        y = (1 - t) ** 3 * start[1] + 3 * (1 - t) ** 2 * t * control1[1] + 3 * (1 - t) * t ** 2 * control2[1] + t ** 3 * end[1]
        points.append((x, y))
    return points

"""